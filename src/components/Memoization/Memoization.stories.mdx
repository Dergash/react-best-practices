import { Meta, Story, Preview } from "@storybook/addon-docs/blocks";
import LoadingImages from "../LoadingImages";

import Memoization from "./Memoization";

<Meta title="Memoization" component={Memoization} />

# Memoization

In other words: caching components, functions and values.

[Loading data](./?path=/docs/loading-data--default-values-as-placeholders-loading-state) and [images](./?path=/docs/loading-images--art-direction-with-cloudinary) leverages the power of caching using third party solutions. For components and functions we have built-in mechanism provided by React out of the box: `React.memo()` and `useMemo()`, `useCallback()`.

## Caching components

Introduced rencently `React.memo()`:

> Bails out components from rendering when their input props are the same &mdash; via [React v16.6.0: lazy, memo and contextType](https://reactjs.org/blog/2018/10/23/react-v-16-6.html)

That makes one think why don't memoize every component? The answer is: [avoid premature optimizations](./?path=/docs/memoization--storybookdocsonly). React is fast enough and every code added in plus might cause more harm than benefit.

### Measure first

A good starting point to see which component might need memoization is to use the React profiler.

<LoadingImages
  images={false}
  src="memoization-1.png"
  alt="The React profiler"
/>

`Repeat`, `Meta` and `TypographicGrid` are the components specific to this app &mdash; written by hand &mdash; which are the most time consuming among their peers.

Their loading times are:

```
| Component       | Loading time (ms)                         | Average |
|-----------------|-------------------------------------------|---------|
|                 | 1st load | 2nd load | 3rd load | 4th load |         |
|-------------------------------------------------------------|---------|
| Repeat          | 3.7, 3.1 | 4.0, 3.8 | 13 , 2.6 | 4.2, 2.6 | 4.625   |
| Meta            | 0.8      | 1.4      | 1        | 1.3      | 1.125   |
| TypographicGrid | 0.7      | 0.8      | 4.5      | 0.8      | 1.7     |
```

Memoizing them brings in the following results:

```
| Component       | Loading time (ms)                         | Average |
|-----------------|-------------------------------------------|---------|
|                 | 1st load | 2nd load | 3rd load | 4th load |         |
|-------------------------------------------------------------|---------|
| Repeat          | 2.5, 2.4 | 3.1, 3.1 | 6.5, 3.1 | 3.5, 2.2 | 3.3     |
| Meta            | 0.9      | 1.1      | 0.9      | 1.4      | 1.075   |
| TypographicGrid | 1.8      | 0.8      | 1        | 0.7      | 1.075   |
```

It seems they all worth memoized in this context. However, this feature needs more research.

## Caching values

By definition `useMemo(() => memoizedValue(a, b), [a, b])` returns a memoized value:

> Will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render. &mdash; via [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html)

Memoized value can be anything from a function &mdash; like the example above &mdash; to a value: `useMemo(() => ['snickers', 'skittles', 'twix', 'milky way'], [])`.

There is a special hook &mdash; `useCallback()` &mdash; for memoizing functions _only_. Perhaps a best practice would be to use `useMemo()` for memorizing values only. See [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback).

```
function Blub() {
	const bar = React.useCallback(() => {}, [])
	const baz = React.useMemo(() => [1, 2, 3], [])
	return <Foo bar={bar} baz={baz} />
}
```

Again one could ask: why don't wrap everything into a `useMemo()`? The answer is:

> Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in useEffect, not useMemo. &mdash; via [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html)

In other words: no business logic. And hooks are business logic. They can't be memoized.

## Caching functions

By definition: `useCallback(fn, deps)` is equivalent to `useMemo(() => fn, deps)` and returns a memoized callback.

> This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders. &mdash; via [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html)

The keywords are referential equality.

## When to use them?

There are two cases when `useMemo` and `useCallback` should be used:

> 1. Referential equality
> 2. Computationally expensive calculations
>    &mdash; via [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback).

### Referential equality

In Javascript only primitives are equal; more complex stuff like arrays, objects, functions behave differently.

> When you define an object inside your React function component, it is not going to be referentially equal to the last time that same object was defined (even if it has all the same properties with all the same values). &mdash; via [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)

```
true === true // true
false === false // true
1 === 1 // true
'a' === 'a' // true

{} === {} // false
[] === [] // false
() => {} === () => {} // false
```

Many times in React referential equality is used to check if an operation has to be performed or not. Both `useEffect`, `useMemo`, `useCallback` relies on a dependencies array to check if they need to execute. If in the dependencies array non-primitives are passed they will always trigger the execution. If these non-primitives are memoized they won't trigger the execution.

#### Example 1

From [Headway.io](https://headway.io/blog/react-optimize-components-memo-usememo-usecallback/)

```
const Parent = () => {
	const [showExtraDetails, setShowExtraDetails] = useState(false);

	return (
		<Child onClick={() => { showData(showExtraDetails); }/>
	);
}
```

> This component will cause Child to re-render every time Parent does, even if Child is a PureComponent or wrapped in React.memo, because the onClick will be different every render. useCallback can handle this situation like so:

```
const Parent = () => {
	const [showExtraDetails, setShowExtraDetails] = useState(false);

	const handleClick = useCallback(
	  () => {
	    showData(showExtraDetails);
	  },
	  [showExtraDetails],
	);

	return (
		<Child onClick={handleClick}/>
	);
}
```

> Now handleClick will have the same value until showExtraDetails changes, which will reduce the number of times Child renders.

#### Example 2.

From [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback).

```
function Foo({bar, baz}) {
	React.useEffect(() => {
		const options = {bar, baz}
		buzz(options)
	}, [bar, baz])

	return <div>foobar</div>
}

function Blub() {
	/**
	 * If `bar`, `baz` is not memoized the `useEffect` in `Foo` will be always executed.
	 */
	const bar = React.useCallback(() => {}, [])
	const baz = React.useMemo(() => [1, 2, 3], [])
	return <Foo bar={bar} baz={baz} />
}
```

### Computationally expensive calculations

These are the rare occasions.

Checking the current example project is hard to find a reason to use memoization to reduce expensive calculations.

In the `LoadingDataApiAxios` component while the data is loading a placeholder is displayed:

```
/**
 * Loads the data
 */
const { data } = useDataAPI(
  ArticlesPlaceholder(placeholder),
  "http://hn.algolia.com/api/v1/search?query=redux",
  "hits"
);
```

The `placeholder` prop is constant &mdash; is defined as a proptype and never gets touched. That makes the `ArticlesPlaceholder` function ideal to be memoized:

```
/**
 * Creates the placeholder
 */
const articlesPlaceholder = useCallback(() => ArticlesPlaceholder(placeholder), [
  placeholder
]);

/**
 * Loads the data
 */
const { data } = useDataAPI(
  articlesPlaceholder,
  "http://hn.algolia.com/api/v1/search?query=redux",
  "hits"
);
```

The number of re-renders before memoization was three; now is a single one. That's great but [not sure](https://kentcdodds.com/blog/usememo-and-usecallback) if it reduces the component load speed!

Let's measure it with React profiler:

```
| Articles  | Loading time (ms)                         | Average |
|-----------|-------------------------------------------|---------|
|           | 1st load | 2nd load | 3rd load | 4th load |         |
| ----------------------------------------------------------------|
| w/o memo  | 5.8      | 3.2      | 3.5      | 3.8      | 4.075   |
| with memo | 3.8      | 4.2      | 3.8      | 4.4      | 4.05    |
```

## Summing up

1. Use `React.memo()` to memoize components only when the performance measurements make it required.
2. `useCallback()` to memoize functions which will be used in referential equality checks.
3. `useMemo()` to memoize values which will be used in referential equality checks.
4. When performance measurements require wrap expensive calculations into `useCallback()` or `useMemo()`

## Resources

- [React v16.6.0: lazy, memo and contextType](https://reactjs.org/blog/2018/10/23/react-v-16-6.html)
- [React: Optimize Components with React.memo, useMemo, and useCallback](https://headway.io/blog/react-optimize-components-memo-usememo-usecallback/)
- [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html)
- [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)
