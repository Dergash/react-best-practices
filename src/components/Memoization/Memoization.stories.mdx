import { Meta, Story, Preview } from "@storybook/addon-docs/blocks";
import LoadingImages from "../LoadingImages";

import Memoization from "./Memoization";

<Meta title="Memoization" component={Memoization} />

# Memoization

In other words: caching components, functions and values.

[Loading data](./?path=/docs/loading-data--default-values-as-placeholders-loading-state) and [images](./?path=/docs/loading-images--art-direction-with-cloudinary) leverages the power of caching using third party solutions. For components and functions we have built-in mechanism provided by React out of the box: `React.memo()` and `useMemo()`, `useCallback()`.

## Caching components

Introduced rencently `React.memo()`:

> Bails out components from rendering when their input props are the same &mdash; via [React v16.6.0: lazy, memo and contextType](https://reactjs.org/blog/2018/10/23/react-v-16-6.html)

That makes one think why don't memoize every component? The answer is: [avoid premature optimizations](./?path=/docs/memoization--storybookdocsonly). React is fast enough and every code added in plus might cause more harm than benefit.

### Measure first

A good starting point to see which component might need memoization is to use the React profiler.

<LoadingImages
  images={false}
  src="memoization-1.png"
  alt="The React profiler"
/>

`Repeat`, `Meta` and `TypographicGrid` are the components specific to this app &mdash; written by hand &mdash; which are the most time consuming among their peers.

Their loading times are:

```
| Component       | Loading time (ms)                         | Average |
|-----------------|-------------------------------------------|---------|
|                 | 1st load | 2nd load | 3rd load | 4th load |         |
|-------------------------------------------------------------|---------|
| Repeat          | 3.7, 3.1 | 4.0, 3.8 | 13 , 2.6 | 4.2, 2.6 | 4.625   |
| Meta            | 0.8      | 1.4      | 1        | 1.3      | 1.125   |
| TypographicGrid | 0.7      | 0.8      | 4.5      | 0.8      | 1.7     |
```

Memoizing them brings in the following results:

```
| Component       | Loading time (ms)                         | Average |
|-----------------|-------------------------------------------|---------|
|                 | 1st load | 2nd load | 3rd load | 4th load |         |
|-------------------------------------------------------------|---------|
| Repeat          | 2.5, 2.4 | 3.1, 3.1 | 6.5, 3.1 | 3.5, 2.2 | 3.3     |
| Meta            | 0.9      | 1.1      | 0.9      | 1.4      | 1.075   |
| TypographicGrid | 1.8      | 0.8      | 1        | 0.7      | 1.075   |
```

It seems they all worth memoized in this context. However, this feature needs more research.

## Caching values

By definition `useMemo(() => memoizedValue(a, b), [a, b])` returns a memoized value:

> Will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render. &mdash; via [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html)

Memoized value can be anything from a function &mdash; like the example above &mdash; to a value: `useMemo(() => ['snickers', 'skittles', 'twix', 'milky way'], [])`.

There is a special hook &mdash; `useCallback()` &mdash; for memoizing functions _only_. Perhaps a best practice would be to use `useMemo()` for memorizing values only. See [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback).

```
function Blub() {
	const bar = React.useCallback(() => {}, [])
	const baz = React.useMemo(() => [1, 2, 3], [])
	return <Foo bar={bar} baz={baz} />
}
```

Again one could ask: why don't wrap everything into a `useMemo()`? The answer is:

> Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in useEffect, not useMemo. &mdash; via [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html)

In other words: no business logic. And hooks are business logic. They can't be memoized.

## Caching functions

By definition: `useCallback(fn, deps)` is equivalent to `useMemo(() => fn, deps)` and returns a memoized callback.

> This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders. &mdash; via [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html)

The keywords are referential equality.

## Examples

### Callback functions

[Headway.io](https://headway.io/blog/react-optimize-components-memo-usememo-usecallback/)

```
const Parent = () => {
	const [showExtraDetails, setShowExtraDetails] = useState(false);

	return (
		<Child onClick={() => { showData(showExtraDetails); }/>
	);
}
```

> This component will cause Child to re-render every time Parent does, even if Child is a PureComponent or wrapped in React.memo, because the onClick will be different every render. useCallback can handle this situation like so:

```
const Parent = () => {
	const [showExtraDetails, setShowExtraDetails] = useState(false);

	const handleClick = useCallback(
	  () => {
	    showData(showExtraDetails);
	  },
	  [showExtraDetails],
	);

	return (
		<Child onClick={handleClick}/>
	);
}
```

> Now handleClick will have the same value until showExtraDetails changes, which will reduce the number of times Child renders.

### Simple functions

In the `LoadingDataApiAxios` component while the data is loading a placeholder is displayed:

```
/**
 * Loads the data
 */
const { data } = useDataAPI(
  ArticlesPlaceholder(placeholder),
  "http://hn.algolia.com/api/v1/search?query=redux",
  "hits"
);
```

The `placeholder` prop is constant &mdash; is defined as a proptype and never gets touched. That makes the `ArticlesPlaceholder` function ideal to be memoized:

```
/**
 * Creates the placeholder
 */
const articlesPlaceholder = useCallback(() => ArticlesPlaceholder(placeholder), [
  placeholder
]);

/**
 * Loads the data
 */
const { data } = useDataAPI(
  articlesPlaceholder,
  "http://hn.algolia.com/api/v1/search?query=redux",
  "hits"
);
```

The number of re-renders before memoization was three; now is a single one. That's great but [not sure](https://kentcdodds.com/blog/usememo-and-usecallback) if it reduces the component load speed!

Let's measure it with React profiler:

```
| Articles | Load #1 | Load #2 | Load #3 | Load #4 | Average |
| -----------------------------------------------------------|
| no memo  | 5.8     | 3.2     | 3.5     | 3.8     | 4.075   |
| useMemo  | 3.8     | 4.2     | 3.8     | 4.4     | 4.05    |
```

## Reference equality

## Resources

- [React v16.6.0: lazy, memo and contextType](https://reactjs.org/blog/2018/10/23/react-v-16-6.html)
- [React: Optimize Components with React.memo, useMemo, and useCallback](https://headway.io/blog/react-optimize-components-memo-usememo-usecallback/)
- [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html)
- [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)
