import { Meta, Story, Preview } from "@storybook/addon-docs/blocks";
import LoadingImages from "../LoadingImages";

import Memoization from "./Memoization";

<Meta title="Memoization" component={Memoization} />

# Memoization

In other words: caching components and functions.

[Loading data](./?path=/docs/loading-data--default-values-as-placeholders-loading-state) and [images](./?path=/docs/loading-images--art-direction-with-cloudinary) leverages the power of caching using third party solutions. For components and functions we have built-in mechanism provided by React out of the box: `React.memo()` and `useMemo()`, `useCallback()`.

## Caching components

If a component:

1. Is pure and functional
2. Renders often
3. Has medium to big size

then it can be wrapped into `React.memo()` and it will be cached.

In fact any component can be memoized but those not satisfying the conditions above [might do more harm than good](https://dmitripavlutin.com/use-react-memo-wisely/).

### Pure and functional

Pure and functional can be further refined. They are components which:

- Render something (ie. functional)
- Have static props which render the same result (ie. pure)
  - Like `Meta`, `Logo`, `Reset`, `TypographicGrid`, `Link` &mdash; they always have the same props and render the same results
  - Unlike `Repeat` &mdash; where props are dynamic based on a state or loop variable and each render produces a different result.

Example of a component which worth caching:

```
/**
 * Displays <meta> tags in <header>
 *
 * Props are static like `My app`, `http://my.app`, 'This is my app'
 * The same result is rendered for the same props
 */
const Meta = props => {
  const { title, url, description } = props;

  return (
    <Helmet>
      <title>{title}</title>
      <meta name="title" content={title} />
      <meta name="description" content={description} />
      <meta name="url" content={url} />
      <meta
        name="viewport"
        content="minimum-scale=1, initial-scale=1, width=device-width, shrink-to-fit=no"
      />
    </Helmet>
  );
};
```

Example of a component which won't worth caching:

```
/**
 * Imitates the for loop inside JSX.
 *
 * The `children` prop is dynamic
 * The rendered result is always different: a children component which depends on a loop variable
 *
 * <Repeat numberOfTimes={numberOfHorizontalLines} startAt={0}>
 * 	{i => <HorizontalRhythmLine key={i} lineColor={lineColor} />}
 * </Repeat>
 */
const Repeat = props => {
  const { startAt, numberOfTimes, children } = props;

  let ret = [];
  const endAt = startAt + numberOfTimes;

  for (let i = startAt; i < endAt; i++) {
    ret.push(children(i));
  }

  return ret;
};
```

### Measure first

A good starting point to see which component might need memoization is to use the [React profiler](https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab)

<LoadingImages images={false} src="memoization-1.png" alt="Memoization" />

`Repeat`, `Meta` and `TypographicGrid` are components specific to this app and can be memoized. The last two satisfy the criterias for memoization.

Memoizing them brings in the results:

<LoadingImages images={false} src="memoization-2.png" alt="Memoization" />

## Resources

- [Use React.memo() wisely](https://dmitripavlutin.com/use-react-memo-wisely/)
