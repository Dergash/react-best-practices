import { Meta, Story, Preview } from "@storybook/addon-docs/blocks";

import State from "./State";

<Meta title="State" component={State} />

# State

Everything in React rolls around the concept of state.

In the past everything rolled around URLs. Requests were made to them and responses received. This was called AJAX, REST, CRUD, MVC and so forth. Now one has to [forget all these](https://kentcdodds.com/chats-with-kent-podcast/seasons/01/episodes/realigning-your-model-of-react-after-hooks-with-dan-abramov) to get the React way easier.

By definition, in React one has to:

> Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. &mdash; via [Reactjs.org](https://reactjs.org/)

The keywords are design and state vs. request and response. Focus on the first two and the rest is solved elegantly by React.

Designing apps with React was shifted to the front-end / user interface and the back-end is completely ignored in this process. In the past the design happened on the backend &mdash; API first, Model and Controller first &mdash; then the user interface was constructed around.

With state React introduced a powerful mechanism to manage all kind of changes on the user interface &mdash; coming either from user interactions or from the underlying network and services infrastucture.

In the past there were no such mechanisms at all. The solution connecting content (HTML) with presentation (CSS) and behavior (Javascript) into a programmable whole was ad-hoc &mdash; through naming conventions (class names) and obscure methodologies like Atomic design, BEM, OOCSS, SMACSS &mdash; all proved to be impossible to scale.

Now React puts a mathematical model of computation &mdash; [finite-state machines](https://en.wikipedia.org/wiki/Finite-state_machine) &mdash; at the core and sole basis of application design and development. With that new perspectives are opened &mdash; from data-driven applications to autogenerated tests.

React takes out the subjective part from design and development &mdash; building APIs, naming things &mdash; and replaces with scientific methods achieving more error-prone solutions at a larger scale.

## Thinking in React

The [official guide](https://reactjs.org/docs/thinking-in-react.html) for building React apps defines the process in five steps:

1. Define component hierarchy
2. Build a static version
3. Identify application state
4. Implement state
5. Add inverse data flow

Behind the process there is theory:

- 1. Information architecture
- 2., 5. Data flow
- 3., 4. Finite state machines

And there are tools to help:

- [Understanding Information Architecture](https://prezi.com/aafmvya6bk7t/understanding-information-architecture/)
- xxx
- [State machines and statecharts for the modern web](https://xstate.js.org/)

## Resources

- [Realigning Your Model of React After Hooks - With Dan Abramov](https://kentcdodds.com/chats-with-kent-podcast/seasons/01/episodes/realigning-your-model-of-react-after-hooks-with-dan-abramov)
- [Finite-state machine](https://en.wikipedia.org/wiki/Finite-state_machine)
- [Write Fewer Tests! - From Automation to Autogeneration](https://slides.com/davidkhourshid/mbt#/)
- [Relay - A JavaScript framework for building data-driven React applications](https://relay.dev/)
- [Tomorrowww - Devices as designers](http://metamn.io/beat/tomorrowww/)
- [Thinking in React](https://reactjs.org/docs/thinking-in-react.html)
- [Understanding Information Architecture](https://prezi.com/aafmvya6bk7t/understanding-information-architecture/)
