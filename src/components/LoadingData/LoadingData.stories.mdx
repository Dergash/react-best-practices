import { Meta, Story, Preview } from "@storybook/addon-docs/blocks";
import LoadingData from "./LoadingData";
import LoadingDataGraphQLApollo from "../LoadingDataGraphQLApollo";

import Img, { CloudimageProvider } from "react-cloudimage-responsive";
import cloudimageConfig from "../../cloudimageConfig.js";

<Meta title="Loading data" component={LoadingData} />

# Loading data

Perhaps every React app deals with data. It loads from a database, from an API, from the filesystem &mdash; you name it.

There are two well established ways to make interacting with data easy: `GraphQL` and `REST API`.

`GraphQL` is the [modern way](http://metamn.io/react/graphql-and-rest-apis-with-aws/). It enables data driven applications. `REST` is &mdash; still &mdash; based on old, web-specific paradigms like `URL` and `CRUD`.

On both fronts there are clear winner libraries to rely.

`Apollo` for GraphQL and `Axios` for REST APIs. Both of them work more or less in the same way making easy to a React developer to abstract away their differences.

## Performance

Fetching data from remote location is considered a time consuming task which needs to be optimized.

Modern tools, frameworks and services are competing to solve this problem for us. In modern times we don't have to think about performance optimizations &mdash; just stick to the standards and let the magic happen under the hood.

### Apollo GraphQL

Apollo GraphQL is such a modern tool. For example:

> Apollo Client takes care of the request cycle from start to finish, including tracking loading and error states for you. There's no middleware to set up or boilerplate to write before making your first request, nor do you need to worry about transforming and caching the response. All you have to do is describe the data your component needs and let Apollo Client do the heavy lifting. ðŸ’ª

> You'll find that when you switch to Apollo Client, you'll be able to delete a lot of unnecessary code related to data management. The exact amount will vary depending on your application, but some teams have reported up to thousands of lines. While you'll find yourself writing less code with Apollo, that doesn't mean you have to compromise on features! Advanced features like optimistic UI, refetching, and pagination are all easily accessible through useQuery options.

> Just by setting up Apollo Client, you get an intelligent cache out of the box with no additional configuration required. [...] Caching a graph is no easy task, but we've spent two years focused on solving it.

And the list [continues](https://www.apollographql.com/docs/react/why-apollo/).

### Axios REST API

In [AJAX and APIs](https://reactjs.org/docs/faq-ajax.html) React officially recommends using Axios. In [How to fetch data in React](https://www.robinwieruch.de/react-fetching-data/) Robin Wieruch &mdash; one of the React thought leaders &mdash; recommends Axios.

Checking [Axios](https://github.com/axios/axios) we might be surprised. Unlike Apollo for GraphQL it tells nothing about data, caching and performance. It just tells: "Promise based HTTP client for the browser and node.js"

To make performant REST API operations one has to look further.

## Placeholders

Loading data is a time consuming operation lasting from miliseconds to seconds. To make this delay unobtrusive on the UI placeholders are used as a best practice.

There are different types of placeholders from spinners, `Loading...` text to complete monochromatic mockups as seen lately on Facebook and Instagram.

![Placeholder](https://user-images.githubusercontent.com/4838076/34308760-ec55df82-e735-11e7-843b-2e311fa7b7d0.gif)

The best placeholder is no placeholder. Next to it is the one which mimics exactly the shape of the real data and produces no surprise &mdash; subtle cognitive dissonance &mdash; when the real data arrives.

### Default values as placeholders

When loading data from a remote endpoint we know apriori its shape. This shape can be prefilled with default values and presented during the loading process.

#### Example:

The shape of the data:

```Javascript
const query = gql`
  query generalSettings {
    generalSettings {
      title
      url
      description
    }
  }
`;
```

The default values:

```Javascript
const defaultProps = {
  placeholder: {
    numberOfRows: 1, // This row will be shown 3 times for `title`, `url`, `description`
    rowLength: 20, // This can be further optimized after the first load
    content: "/ "
  }
};
```

The loading state:

<Preview>
  <Story name="Default values as placeholders, loading state">
    <LoadingDataGraphQLApollo displayData={false} />
  </Story>
</Preview>

The loaded state:

<Preview>
  <Story name="Default values as placeholders, loaded">
    <LoadingDataGraphQLApollo />
  </Story>
</Preview>

#### Further optimizations

##### `rowLength`

After the first load the length of each row can be saved locally.
Then on consecutive loads each placeholder will have the exactly same length as the text it replaces &mdash; achieving the perfect shape

##### Number of rows

In this current case we know exactly we'll have 3 rows.

In other cases &mdash; when loading a list of categories we don't know how many rows will be returned. Six? Twenty?

Creating a perfect placeholder for this case is impossible at the first load. It's a guess. However if we save the number of rows locally then using on consecutive loads we can have &mdash; again &mdash; the perfect shape.

### SVG mockups as placeholders

Since the SVG format is pure markup it is programmable. That makes it as valuable as Default values to offer perfectly shaped placeholders.

[Some libraries](https://github.com/danilowoz/react-content-loader) offer basic options to make placeholders follow the shape of the data.

When SVG placeholders are static &mdash; a three-row list placeholder used for a 15 rows result &mdash; they can be as ugly as the good old loading animations and spinners.

In the case above the browser will stretch the 3 row SVG to fill the space designed for 15 rows of data &mdash; distorting the shape and ruining the experience.

Making SVG look and behave better than default values based placeholders is possible with lots of dedication.

## Re-renders

For someone coming outside the React world _unnecessary re-renders_ might sound a thing to worry about. How unnecessary re-renders look like? In this project we have:

```
| Component                          | Re-renders            |
|------------------------------------|---------------------|
|                                    | 1st load | 2nd load |
|------------------------------------|----------|----------|
| LoadingDataApiAxios                | 3        | 1        |
| LoadingDataApiAxiosPlaceholderSVG  | 3        | 1        |
| LoadingDataGraphQLApollo           | 2        | 1        |
| LoadingDataGraphQLApolloPagination | 2        | 1        |
```

The number of re-renders can be seen right-side in the console:

<CloudimageProvider config={cloudimageConfig}>
  <Img
    src="performance-rerenders.png"
    alt="Re-renders"
    ratio={1.83}
    filter="fsharp4 fcontrast100 fbrigth255"
  />
</CloudimageProvider>

In other frameworks on first load there might be a single render.
Here with Axios / REST API we have three and with Apollo / GraphQL we have two renders.

Two is ok: the first is for the placeholder the second is for the real data. On Axios why there is one more render &mdash; needs to be investigated. With keeping this in mind:

> MOST OF THE TIME YOU SHOULD NOT BOTHER OPTIMIZING UNNECESSARY RERENDERS. (by [Kent C. Dodds](https://kentcdodds.com/blog/usememo-and-usecallback))

## Pagination

Fetching new data from the server and an eventual cancellation of the whole process.

### Apollo GraphQL

- With `fetchMore` a new set of data can be requested.
- Both offset and cursor based navigation is supported. On cursor based navigation also Relay-style is supported.
- It can return two kind of results:
  - `Next page`: simply loads the next page
  - `Load more`: keeps old data and adds the new data

### Axios REST

- With `doFetch` a new set of data can be requested.
- It offers `Next page` like navigation

### Cancellation

Is still a gray area in React. Suspense for Data Fetching, caching will come officially to React later this year.
Until then there are [(complicated) workarounds](https://blog.axlight.com/posts/how-to-create-react-custom-hooks-for-data-fetching-with-useeffect/).

## Error handling

Catching errors and making them unobtrusive for the UI.

### Custom

1. The error is logged where first occurs. In hooks, probably.
2. Default values are returned to make sure the calling component will receive the expected results and won't break the UI.
3. The calling component handles the error in its own taste.

### Error boundaries

The React way is to use error boundaries. They can be used only with the class syntax in the current React version.

### Apollo GraphQL

- Can be configured how to handle the different types of errors.
- `graphQLErrors` offers verbose error messages

### Axios REST

- The `use-data-api` doesn't return error messages just an error flag.

## Testing

TBD...

## Resources

- [GraphQL and REST APIs with AWS](http://metamn.io/react/graphql-and-rest-apis-with-aws/)
- [Why Apollo Client?](https://www.apollographql.com/docs/react/why-apollo/)
- [AJAX and APIs](https://reactjs.org/docs/faq-ajax.html)
- [How to fetch data in React](https://www.robinwieruch.de/react-fetching-data/)
- [Axios](https://github.com/axios/axios)
- [react-content-loader](https://github.com/danilowoz/react-content-loader)
- [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)
